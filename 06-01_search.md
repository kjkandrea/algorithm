# 탐색

여러 개의 원소로 구성된 데이터에서 원하는 값을 갖는 원소를 찾는 것

## 순차 탐색

* 탐색 : O(n)
* 삭제 : O(n). 삭제할 원소의 순차 탐색 후 마지막 원소의 이동
* 삽입 : O(1). 리스트의 마지막에 추가하는 데 상수 시간만 필요

=> 비정렬된 크기가 작은 데이터에 적합

## 이진 탐색

정렬된 리스트 형태로 주어진 원소들을 절반씩 줄어 가면서 원하는 값을 찾는 방법

연결 리스트 구조에서는 이진 탐색 자체가 불가능

* 탐색 : O(log n)
* 삽입 : O(n). 올바른 위치에 삽입 후 밀리는 원소를 한 칸씩 이동해야하므로
* 삭제 : O(n). 데이터 찾기 + 원소들을 한 칸씩 이동

삽입, 삭제가 빈번하다면 부적합

## 이진 탐색 트리

* 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 작다.
* 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키 값보다 크다.

후속자(successor. 계승자) 노드 : 어떤 노드의 바로 다음 키값을 갖는 노드 

* 삭제 : 삭제되는 노드의 자식 노드의 개수에 따라 구분해서 처리
    1. 자식 노드가 없음 : 자신만 삭제
    2. 자식 노드가 1개 : 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따로 올림
    3. 자식 노드가 2개 :  삭제되는 노드의 후속자 노드를 삭제되는 노드의 위치로 올리고, 후속자 노드를 삭제되는 노드로 취급하여 자식 노드의 개수에 따라 다시 처리

* 탐색, 삽입, 삭제 : 
  * 완전 이진트리의 경우 O(log n)
  * 모든 노드의 차수가 1인 경우 O(n)

## 2-3-4 트리

모든 리프 노드의 레벨이 동일한 균형 탐색 트리

* 2-노드 : 1개의 키, 2개의 자식
* 3-노드 : 2개의 키, 3개의 자식
* 4-노드 : 3개의 키, 4개의 자식

탐색
* 방문한 노드의 모든 키 값과 찾는 값을 비교
* 탐색 과정에서 4-노드를 만나면 항상 노드 분할을 수행. 4-노드를 3개의 2-노드로 분할 => 균형을 지키는 방법

* 탐색, 삽입, 삭제 : O(log n)

